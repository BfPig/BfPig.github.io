---
title: 重学前端03-JavaScript类型：关于类型，有哪些你不知道的细节？
date: 2019-06-01 16:11:05 +0800
comments: true
categories: [前端笔记]
tags:
  - 前端
  - 重学前端
---
# 提问

- 为什么有的编程规范要求用 void 0 代替 undefined？
- 字符串有最大长度吗？
- JS里为什么0.1+0.2不等于0.3
- ES6新加入的Symbol是什么
- 为什么给对象添加的方法基本都能用在类型上？


运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于 7 个类型之一。从变量、参数、返回值到表达式中间结果，任何 JavaScript 代码运行过程中产生的数据，都具有运行时类型
<!--more-->

# 类型

JavaScript 语言的每一个值都属于某一种数据类型。JavaScript 语言规定了 7 种语言类型。语言类型广泛用于变量、函数参数、表达式、函数返回值等场合。根据最新的语言标准，这 7 种语言类型是：

1.Undefined
2.Null
3.Boolean
4.String
5.Number
6.Symbol
7.Object

## Undefined、Null

Undefined:未定义，undefined是变量，可以被修改
Null:定义了但是为空，null是关键字

`void 运算符 对给定的表达式进行求值，然后返回 undefined。`

规范中使用 `void 0` 代替 `undefined`原因是undefined是变量，可以被修改，而`void 0`返回的绝对是undefined。

## String

String有最大长度是2^53-1，这个长度并不是字符数。

String的意义并非是”字符串“，而是字符串的UTF16编码，所以，字符串的最大长度，实际上是受字符串的编码长度影响的。

	Note：现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF 是 Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）。


JavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征。

JavaScript 字符串把每个 UTF16 单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，你应该格外小心。

JavaScript 这个设计继承自 Java，最新标准中是这样解释的，这样设计是为了“性能和尽可能实现起来简单”。因为现实中很少用到 BMP 之外的字符。


## Number

JavaScript 中的 Number 类型有 18437736874454810627(即 2^64-2^53+3) 个值。

JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况：

- [NaN](https://kinboyw.github.io/2018/11/13/%E7%A5%9E%E5%A5%87%E7%9A%84NaN/)
- Infinity，无穷大；
- -Infinity，负无穷大。


JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。

根据双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。

同样根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行） 来比较，一段著名的代码，这也正是我们第三题的问题，为什么在 JavaScript 中，0.1+0.2 不能 =0.3：

```javascript
console.log( 0.1 + 0.2 == 0.3);
```

这里输出的结果是 false，说明两边不相等的，这是浮点运算的特点，也是很多同学疑惑的来源，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。
所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值：

```javascript
console.log( Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON);
```

## Symbol

定义：Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑。


…………

未完待续
